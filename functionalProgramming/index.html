<html>
<head>
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/white.css">
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <p>Functional Programming</p>
            <p>Introduction</p>
            <p>
                Functional programming characteristics
            <ul>
                <li>There are not assignment statements:</li>
                <li>
                    Variables once given a value, never change
                </li>
                <li>
                    No side effects because a function can just compute the result
                </li>
                <li> Referentially transparent: The output will depend only in its input. One can freely replace values
                    by their values
                </li>
            </ul>

            </p>
        </section>
        <section>
            <p>Functional programming is sometimes considered a set of techniques:</p>
            <ul>
                <li>First-class functions</li>
                <li>Anonymous functions</li>
                <li>Closures</li>
                <li>Currying</li>
                <li>Lazy evaluation</li>
                <li>Parametric polymorphism</li>
                <li>Algebraic data types</li>
            </ul>
        </section>
        <section>
            <p>What does it mean that in FP there are no side effects?</p>
            <ul>
                <li>
                    No mutation of variables
                </li>
                <li>No printing to the console or to any device</li>
                <li>No writing to files, databases, networks and so on</li>
                <li>No excetion throwing</li>
            </ul>
            <p>This is the theory, but if a program doesn't have an observable result won't be very useful.
                The idea is that the interactio with the outside world won't occur in the middle of a computation,
                but only when you finish the computation.
            </p>
        </section>
        <section>
            <p>Is this code functional?</p>
            <pre><code data-trim data-noescape>
            public static int div(int a, int b) {
                log.info("divide {} / {} ", a, b)
                return a / b;
            }
            </code></pre>
        </section>
        <section>
            <p>Benefits</p>
            <ul>
                <li>FP are deterministic, because the result will depend just from the input are easier to understand
                </li>
                <li>Fuc programs are easier to test because there are no side effects (no interaction with the outside
                    world)
                </li>
                <li>FP are more modular, because they are built from functions with just input and output</li>
                <li>FP makes compositions and recombination much easier.</li>
                <li>Functional programs are inherently thread-safe because they avoid mutation of shared state</li>

            </ul>
        </section>
        <section>
            <p>Functions in Java</p>
            <p>A method can be functional if it respects the requirements of a pure function:</p>
            <ul>
                <li>It must not mutate anything outside the function. No internal mutation may be visible from the
                    outside.
                </li>
                <li>It must not mutate its argument.</li>
                <li>It must not throw errors or exceptions.</li>
                <li>It must always return a value.</li>
                <li>When called with the same argument, it must always return the same result.</li>
            </ul>
            Methods could be functional but you cannot pass a method as an argument, and you cannot compose methods
            without applying them
        </section>

        <section>
            <p>Java functional interface</p>
            <p>Java provides an interface called Function&lt;T,R&gt;  </p>
            <p>T - the type of the input to the function</p>
            <p>R - the type of the result of the function</p>

            And this interface declare 4 methods: R apply(T t), Function andThen(Function after), Function
            compose(Function before), Function identity()

            <pre><code class="java">
            Function&lt;Integer,Integer&gt; duplicate = x -> x * 2

            duplicate.apply(3) // 6
            </code></pre>
        </section>
        <section>
            How would you create a function that first duplicates an integer and after adds it 2?

            <p>Solution</p>
            <pre><code data-trim data-noescape>
Function&lt;Integer, Integer&gt; duplicate = x -> x * 2;
Function&lt;Integer, Integer&gt; add2 = x -> x + 2;

Function&lt;Integer, Integer&gt; duplicateAndSum = duplicate.andThen(add2);
Function&lt;Integer, Integer&gt; duplicateAndSum = add2.compose(duplicate);
Function&lt;Integer, Integer&gt; duplicateAndSum = duplicate.andThen(x -> x + 2);

duplicateAndSum.apply(4) // 10
            </code></pre>
        </section>
        <section>
            <p>What about functions of several arguments?</p>
            <p>A function can contain only a tuple of arguments</p>
            <p>There are 2 options to handle more than one argument:</p>
            <ul>
                <li>Curried functions</li>
                <li>Use tuples of n cardinality: pair, triplet, quartet...</li>
            </ul>
        </section>
        <section>
            <p>Tuples</p>
            <pre><code data-trim data-noescape>
Function&lt;Tuple&lt;Double, Double&gt;, Double&lt; addTax= tuple -> tuple._2 + tuple._2 * tuple._1;

BiFunction&lt;Double, Double, Double&gt; addTax = (price, tax) -> price + (price * tax);
BinaryOperator&lt;Double&gt; addTaxBi = (price, tax) -> price + (price * tax);

//For more than 2 element you will need to create your own function
@FunctionalInterface
interface Function3 &lt;A, B, C, R&gt; {
    public R apply (A a, B b, C c);
}

Function3 &lt;String, Integer, Double, Double&gt; multiAdder = (a, b, c) -> {
    return Double.parseDouble (a) + b + c;
};
            </code></pre>
        </section>
        <section>
            <p>Curried functions (1/2)</p>
            <p>Currying is the fact of evaluating function arguments one by one, producing a new function with one
                argument less on each step.</p>
            <p>Arguments can be applied one by one, each application of one argument returning a new function, except
                for the last one.</p>

            <p>Letâ€™s try to define a function for adding two integers.</p>
            <pre><code data-trim data-noescape>
Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = x -> y -> x + y;

                add.apply(2).apply(3) //5
            </code></pre>

        </section>
        <section>
            WHATTTT?????
        </section>
        <section>
            <p>Partial application</p>
            <p>Currying is related to, but not the same as, partial application.</p>
            <p>Currying is very useful when arguments of a function must be evaluated in different places. Using
                currying, one may evaluate one argument in some component, then pass the result to another component to
                evaluate another argument, and so on until all arguments are evaluated.</p>

            <pre><code data-trim data-noescape>
        Function&lt;Double, Function&lt;Double, Double&gt;&gt; addTax
            = tax -> price -> price + (price * tax);

                Function addTax9 = addTax.apply(9)

                addtax9.apply(100)

            </code></pre>
        </section>

    </div>
</div>
<script src="../reveal.js/js/reveal.js"></script>
<script>
    Reveal.initialize();
    Reveal.configure({slideNumber: 'c/t'});
</script>
</body>
</html>