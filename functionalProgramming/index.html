<html>
<head>
    <link rel="stylesheet" href="../reveal.js/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js/css/theme/league.css">
    <link rel="stylesheet" href="../highlight/styles/default.css">
    <!--<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/styles/default.min.css">-->
    <style type="text/css">
        p,ul,ol{font-size:30px !important}


    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <p>Functional Programming</p>
            <p>Introduction</p>
            <p>
                Functional programming characteristics
            <ul>
                <li>There are not assignment statements:</li>
                <li>
                    Variables once given a value, never change
                </li>
                <li>
                    No side effects because a function can just compute the result
                </li>
                <li> Referentially transparent: The output will depend only in its input. One can freely replace values
                    by their values
                </li>
            </ul>

            </p>
        </section>
        <section>
            <p>Functional programming is sometimes considered a set of techniques:</p>
            <ul>
                <li>First-class functions</li>
                <li>Anonymous functions</li>
                <li>Closures</li>
                <li>Currying</li>
                <li>Lazy evaluation</li>
                <li>Parametric polymorphism</li>
                <li>Algebraic data types</li>
            </ul>
        </section>
        <section>
            <p>What does it mean that in FP there are no side effects?</p>
            <ul>
                <li>
                    No mutation of variables
                </li>
                <li>No printing to the console or to any device</li>
                <li>No writing to files, databases, networks and so on</li>
                <li>No excetion throwing</li>
            </ul>
            <p>This is the theory, but if a program doesn't have an observable result won't be very useful.
                The idea is that the interactio with the outside world won't occur in the middle of a computation,
                but only when you finish the computation.
            </p>
        </section>
        <section>
            <p>Is this code functional?</p>
            <pre><code class="java">
            public static int div(int a, int b) {
                log.info("divide {} / {} ", a, b)
                return a / b;
            }
            </code></pre>
        </section>
        <section>
            <p>Benefits</p>
            <ul>
                <li>FP are deterministic, because the result will depend just from the input are easier to understand
                </li>
                <li>Fuc programs are easier to test because there are no side effects (no interaction with the outside
                    world)
                </li>
                <li>FP are more modular, because they are built from functions with just input and output</li>
                <li>FP makes compositions and recombination much easier.</li>
                <li>Functional programs are inherently thread-safe because they avoid mutation of shared state</li>

            </ul>
        </section>
        <section>
            <p>Functions in Java</p>
            <p>A method can be functional if it respects the requirements of a pure function:</p>
            <ul>
                <li>It must not mutate anything outside the function. No internal mutation may be visible from the
                    outside.
                </li>
                <li>It must not mutate its argument.</li>
                <li>It must not throw errors or exceptions.</li>
                <li>It must always return a value.</li>
                <li>When called with the same argument, it must always return the same result.</li>
            </ul>
            Methods could be functional but you cannot pass a method as an argument, and you cannot compose methods
            without applying them
        </section>

        <section>
            <p>Java functional interface</p>
            <p>Java provides an interface called Function&lt;T,R&gt; </p>
            <p>T - the type of the input to the function</p>
            <p>R - the type of the result of the function</p>

            And this interface declare 4 methods: R apply(T t), Function andThen(Function after), Function
            compose(Function before), Function identity()

            <pre><code class="java">
            Function&lt;Integer,Integer&gt; duplicate = x -> x * 2

            duplicate.apply(3) // 6
            </code></pre>
        </section>
        <section>
            How would you create a function that first duplicates an integer and after adds it 2?

            <p>Solution</p>
            <pre><code data-trim data-noescape>
Function&lt;Integer, Integer&gt; duplicate = x -> x * 2;
Function&lt;Integer, Integer&gt; add2 = x -> x + 2;

Function&lt;Integer, Integer&gt; duplicateAndSum = duplicate.andThen(add2);
Function&lt;Integer, Integer&gt; duplicateAndSum = add2.compose(duplicate);
Function&lt;Integer, Integer&gt; duplicateAndSum = duplicate.andThen(x -> x + 2);

duplicateAndSum.apply(4) // 10
            </code></pre>
        </section>
        <section>
            <p>What about functions of several arguments?</p>
            <p>A function can contain only a tuple of arguments</p>
            <p>There are 2 options to handle more than one argument:</p>
            <ul>
                <li>Curried functions</li>
                <li>Use tuples of n cardinality: pair, triplet, quartet...</li>
            </ul>
        </section>
        <section>
            <p>Tuples</p>
            <pre><code data-trim data-noescape>
Function&lt;Tuple&lt;Double, Double&gt;, Double&lt; addTax= tuple -> tuple._2 + tuple._2 * tuple._1;

BiFunction&lt;Double, Double, Double&gt; addTax = (price, tax) -> price + (price * tax);
BinaryOperator&lt;Double&gt; addTaxBi = (price, tax) -> price + (price * tax);

//For more than 2 element you will need to create your own function
@FunctionalInterface
interface Function3 &lt;A, B, C, R&gt; {
    public R apply (A a, B b, C c);
}

Function3 &lt;String, Integer, Double, Double&gt; multiAdder = (a, b, c) -> {
    return Double.parseDouble (a) + b + c;
};
            </code></pre>
        </section>
        <section>
            <p>Curried functions (1/2)</p>
            <p>Currying is the fact of evaluating function arguments one by one, producing a new function with one
                argument less on each step.</p>
            <p>Arguments can be applied one by one, each application of one argument returning a new function, except
                for the last one.</p>

            <p>Let’s try to define a function for adding two integers.</p>
            <pre><code data-trim data-noescape>
Function&lt;Integer, Function&lt;Integer, Integer&gt;&gt; add = x -> y -> x + y;

                add.apply(2).apply(3) //5
            </code></pre>

        </section>
        <section>
            WHATTTT?????
        </section>
        <section>
            <p>Partial application</p>
            <p>Currying is related to, but not the same as, partial application.</p>
            <p>Currying is very useful when arguments of a function must be evaluated in different places. Using
                currying, one may evaluate one argument in some component, then pass the result to another component to
                evaluate another argument, and so on until all arguments are evaluated.</p>

            <pre><code data-trim data-noescape>
        Function&lt;Double, Function&lt;Double, Double&gt;&gt; addTax
            = tax -> price -> price + (price * tax);

                Function addTax9 = addTax.apply(9)

                addtax9.apply(100)

            </code></pre>
        </section>
        <section>
            <!--I think I will skip the lazy section for the moment-->
            <p>Being Lazy</p>
            <p>Lazy Initialization</p>
            <p>In object-oriented programming we ensure that objects are well constructed before any method calls</p>
            <p>This works well most of the time, but when parts of an object’s internals are heavyweight resources,
                we’ll benefit if we postpone creating them</p>
        </section>
        <section>
            Usual approach
            <pre><code data-trim data-noescape>
                public class Heavy {
                    public Heavy(){
                        System.out.println("Heavy created");
                    }
                }

                public class LoadHeavy {
                    private Heavy heavy;

                    public Heavy getHeavy(){
                        if(
                    }

                }

            </code></pre>
        </section>

        <section>
            <p>Handling Exceptions</p>
            <p>When we have to handle exceptions in FP we have different options:</p>
            <p>One option is to wrap the code in a try and catch and handle the exception</p>

            <pre><code data-trim data-noescape>
    Stream.of("/usr", "/tmp")
        .map(path -> {
            try {
                BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(path)));
                return bufferedReader.readLine();
            } catch (Exception e) {
                return e.getMessage();
            }
        })
        .forEach(System.out::println);
                </code></pre>
        </section>
        <section>
            <p>Another possible solution is to wrap the checked exception and throw a Runtime Exception</p>
            <pre><code data-trim data-noescape>
Stream.of("log.txt", "NoExist.txt")
    .map(path -> {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(path)))){
            return bufferedReader.readLine();
        } catch (Exception e) {
            throw new RuntimeException("File doesn't exist");
        }
    })
    .forEach(System.out::println);
            </code></pre>

        </section>

        <section>
            "Try": The vavr solution to wrap the exception similar to @SneakyThrows from lombok. Will wrap the exception
            in a NonFatalException

            <pre><code data-trim data-noescape>
            Stream.of("log.txt", "NoExist.txt")
                .map(path -> Try.of(() -> new BufferedReader(new FileReader(path))))
                .peek(f -> f.onFailure(f2 -> System.out.println("File does not exist")))
                .filter(Try::isSuccess)
                .forEach(line-> System.out.println(line.get()));
            </code></pre>
        </section>
        <section>
            <p>Either: Represents a value of two possible types. By convention the right is the right value</p>
            Stream.of("log.txt", "NoExist.txt")
            .map(this::eitherLineOrException)
            .map(e->e.getOrElseGet(Throwable::getMessage))
            .forEach(System.out::println);

            private Either
            <IOException
                    , String> eitherLineOrException(String path) {
                try(BufferedReader bufferedReader = new BufferedReader(new FileReader(path))) {
                return Either.right(bufferedReader.readLine());
                } catch (IOException exception) {
                return Either.left(exception);
                }
                }
        </section>

        <section>
            <p>Either or Try?</p>
            <p> Only if you are interested in processing the exception you should use Either</p>
            <p> In most of the cases, specially if you are just interested in propagating the exception you should use
                Try</p>
        </section>

        <section>
            <h1>Functional Programming in Java</h1>
        </section>
        <section>
            <p>Sort list in Java 7</p>
            <p> Before Java 8 we could sort a collection implementing a new Collector </p>
            <pre><code data-trim data-noescape>
        List persons = PersonFixture.persons();
        Collections.sort(persons, new Comparator&lt;Person&gt;() {
            @Override
            public int compare(Person p1, Person p2) {
                return p1.getAge() - p2.getAge();
            }
        });
            </code></pre>
            <p>But how do we do multiple sortings? for instance how do we sort persons by age and then by name?</p>
        </section>
        <section>
            <h3>Sort a list in Java 8</h3>
            <p>In Java 8 we could lambda expressions instead of the new collector and also we can reverse and/or
                concatenate the sorting</p>
            <pre><code data-trim data-noescape>
    persons.stream()
        .sorted(comparing(Person::getAge))
        .forEach(System.out::println);

    persons.stream()
        .sorted(comparing(Person::getAge).reversed())
        .forEach(System.out::println);

    persons.stream()
        .sorted(comparing(Person::getAge).thenComparing(Person::getName))
        .forEach(System.out::println);
        </code></pre>
        </section>

        <section>
            <h3>Using Collector</h3>
            <p>We could add elements to a list using the following code:</p>
            <pre><code data-trim data-noescape>
    List personOlderThan30 = new ArrayList<>();
    persons().stream()
            .filter(p -> p.getAge() > 30)
            .forEach(personOlderThan30::add);

    List personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .collect(Collectors.toList());
            </code></pre>
            Both snippets will produce the same result, but we could run the second version in parallel!
        </section>
        <section>
            <h3>Creating a custom collector</h3>
            <p>You can create a new collector by passing to the collect function 3 parameters:</p>
            <ul>
                <li>The new collection</li>
                <li>The function to add one element</li>
                <li>The function to join 2 collections</li>
            </ul>
            <pre><code data-trim data-noescape>
    List personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);

    JSONArray personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .map(JSONObject::new)
        .collect(JSONArray::new, JSONArray::put, JSONArray::put);
            </code></pre>
        </section>

        <section>
            <h3>Using GroupingBy - Before Java 8</h3>
            <p>Before Java 8 in order to group a list of objects by one attribute you had to something similar to the
                following code:</p>
            <pre><code data-trim data-noescape>
        Map&lt;Integer, List&lt;Person&gt;&gt; hashMap = new HashMap<>();
        List&lt;Person&gt; persons = persons();

        for(Person person : persons) {
            if (!hashMap.containsKey(person.getAge())) {
                List&lt;Person&gt; list = new ArrayList<>();
                list.add(person);
                hashMap.put(person.getAge(), list);
            } else {
                hashMap.get(person.getAge()).add(person);
            }
        }
            </code></pre>
        </section>
        <section>
            <h3>Using GroupingBy in Java 8</h3>
            <p>Java 8 introduced a new collectio for grouping by an attribute</p>
            <p>Also you can use mapping to just return a map of your object</p>
            <pre><code data-trim data-noescape>
    Map personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .collect(Collectors.groupingBy(Person::getAge));
    // {50=[Person(age=50, name=Mary)],
    // 31=[Person(age=31, name=Simon), Person(age=31, name=Matt)]}

    Map personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .collect(Collectors.groupingBy(Person::getAge, mapping(Person::getName, toList())));
    // {50=[Mary], 31=[Simon, Matt]}
            </code></pre>
        </section>
        <section>
            <h3>Using GroupingBy in Java 8</h3>

            <p>Or "reducing" to perform a reduction of the grouping elements</p>
            <pre><code data-trim data-noescape>
     Map personOlderThan30 = persons().stream()
        .filter(p -> p.getAge() > 30)
        .collect(Collectors.groupingBy(Person::getAge,
                reducing(BinaryOperator.maxBy(comparing(Person::getName)))));
// {50=Optional[Person(age=50, name=Mary)], 31=Optional[Person(age=31, name=Simon)]}
            </code></pre>
        </section>
    </div>
</div>
<script src="../reveal.js/js/reveal.js"></script>
<!--<script src="../highlight/highlight.min.js"></script>-->
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
<script>
    Reveal.initialize();
    Reveal.configure({slideNumber: 'c/t', history:true});
    hljs.initHighlightingOnLoad();


</script>
</body>
</html>